//========================================================================================
// Athena++ astrophysical MHD code
// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> and other code contributors
// Licensed under the 3-clause BSD License, see LICENSE file for details
//========================================================================================
//! \file otf.cpp
//  \brief Writes result of on-the-fly analysis. Only root rank writes. Data
//  are stored in 1D array generated by MeshBlock::OTFWorkBeforeOutput. 
//  User needs to keep track of data storage pattern.

// C headers
#include <stdio.h>
#include <stdlib.h>

// C++ headers
#include <iomanip>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>

// Athena++ headers
#include "../athena.hpp"
#include "../coordinates/coordinates.hpp"
#include "../globals.hpp"
#include "../mesh/mesh.hpp"
#include "outputs.hpp"

//----------------------------------------------------------------------------------------
// FormattedTableOutput constructor
// destructor not required for this derived class

OTFOutput::OTFOutput(OutputParameters oparams)
  : OutputType(oparams) {
}

//----------------------------------------------------------------------------------------
//! \fn void OTFOutput:::WriteOutputFile(Mesh *pm)
//  \brief writes OutputData to file as binary. Only root rank writes.
//  First element: pm->time. Second element: int32_t: number of elements in array.
//  Remaining elements: data.

void OTFOutput::WriteOutputFile(Mesh *pm, ParameterInput *pin, bool flag) {
  MeshBlock *pmb=pm->pblock;

  if (Globals::my_rank == 0) { // only root rank writes
    if (pmb != NULL) { // fine to use first block - should have all the information, since root rank
      // create filename consisting of "file_basename"+"."+"XXXXX"+".otf"
      std::string fname;
      char number[6];
      sprintf(number,"%05d",output_params.file_number);
      fname.assign(output_params.file_basename);
      fname.append(".");
      fname.append(number);
      fname.append(".otf");

      // output data
      float *data = new float[pmb->otf_data.len+2];
      data[0] = static_cast<float>(pm->time);
      data[1] = static_cast<float>(pmb->otf_data.len)+0.01;
      for (int s=0; s<pmb->otf_data.len; s++)
        data[2+s] = static_cast<float>(pmb->otf_data.data[s]);

      // open file for output
      FILE *pfile;
      std::stringstream msg;
      if ((pfile = fopen(fname.c_str(),"wb")) == NULL) {
        msg << "### FATAL ERROR in function [OTFOutput::WriteOutputFile]"
            <<std::endl<< "Output file '" <<fname<< "' could not be opened" <<std::endl;
        throw std::runtime_error(msg.str().c_str());
      }
      fwrite(data,sizeof(float),pmb->otf_data.len+2,pfile);
      fclose(pfile);
      delete [] data;
    }
  }

  // increment counters
  output_params.file_number++;
  output_params.next_time += output_params.dt;
  pin->SetInteger(output_params.block_name, "file_number", output_params.file_number);
  pin->SetReal(output_params.block_name, "next_time", output_params.next_time);

  return;
}
